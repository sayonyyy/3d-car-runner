<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Endless Runner</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <style>
        /* CSS Styling */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a0d7e6; /* Light sky blue */
            font-family: sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            touch-action: none; /* Prevent default touch behaviors */
            -webkit-user-select: none; /* Prevent text selection */
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* Prevent tap highlights */
        }
        #container {
            display: block; /* Avoid spacing issues */
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            pointer-events: all;
            z-index: 100;
        }
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* UI Elements */
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 1px 1px 3px black;
            z-index: 50;
        }

        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444; /* Bright red */
            font-size: 4em;
            font-weight: bold;
            text-shadow: 2px 2px 5px black;
            display: none; /* Initially hidden */
            z-index: 101;
            text-align: center;
        }
        
        /* Added CSS for Best Score */
        #best-score {
            margin-top: 5px;
            font-size: 0.8em;
        }

        /* Control Buttons (Mobile) */
        .control-button {
            position: fixed;
            bottom: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3); /* Semi-transparent white */
            border: 3px solid #333;
            color: #333;
            font-size: 2.5em;
            line-height: 74px; /* Center content vertically */
            text-align: center;
            cursor: pointer;
            z-index: 50;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation; /* Optimizes for touch */
            -webkit-user-select: none;
            user-select: none;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.5); /* Increased opacity on active */
        }

        #left-button {
            left: 20px;
        }

        #right-button {
            right: 20px;
        }
    </style>
</head>
<body>
    <div id="loading-screen">Loading...</div>
    <div id="container"></div>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="best-score">Best: 0</div> 
    </div>
    <div id="game-over">GAME OVER!</div>
    <button id="left-button" class="control-button">◀</button>
    <button id="right-button" class="control-button">▶</button>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // --- Configuration Constants ---
        const roadWidth = 10;
        const roadLength = 200;
        const kerbWidth = 0.3;
        const driveSpeed = 0.5; // Scenery speed
        const carMoveSpeed = 0.15; // Player car lateral movement speed
        const carHalfWidth = 1.0; // Approximation for collision
        const enemyCarSpeed = 0.4;
        const buildingSpacing = 15;
        const lightSpacing = 20;
        let carBaseY = 0.51; // Fallback value
        
        // Lane positions (Left, Center, Right) for challenging enemy spawns
        const lanePositions = [-roadWidth / 4, 0, roadWidth / 4]; 

        // --- Global Variables ---
        let scene, camera, renderer, clock;
        let playerCar, enemyCar, points = [];
        let roadLines = [];
        let buildings = [];
        let lights = [];
        let directionalLight;

        let score = 0;
        let bestScore = parseInt(localStorage.getItem('bestScore')) || 0; // Load best score
        let isGameOver = false;
        let moveLeft = false;
        let moveRight = false;

        let playerBox, enemyBox, pointBoxes = [];

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const scoreDisplay = document.getElementById('score');
        const bestScoreDisplay = document.getElementById('best-score'); // New DOM element
        const gameOverDisplay = document.getElementById('game-over');
        const container = document.getElementById('container');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');

        // --- Initialization ---

        function init() {
            clock = new THREE.Clock();

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6);
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, carBaseY + 3, -7);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            container.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 50, -15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 100;
            scene.add(directionalLight);

            // 5. Environment
            createGround();
            createRoad();
            createKerbs();
            setupRoadLines();
            setupBuildings();
            setupLights();
            setupTrafficLights();
            setupPoints();
            
            // Update initial best score display
            bestScoreDisplay.textContent = `Best: ${bestScore}`;

            // 6. Asset Loading
            loadAssets();

            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            setupTouchControls();
        }

        // --- Game Environment Functions (omitted for brevity, assume unchanged) ---
        // ... (All original environment functions like createGround, createRoad, createKerbs, etc., remain here)
        function createGround() {
            const groundGeo = new THREE.PlaneGeometry(roadLength * 1.5, roadLength);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 }); 
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05; 
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createRoad() {
            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555 }); 
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.0;
            road.receiveShadow = true;
            scene.add(road);
        }
        
        function createKerbs() {
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, 0.2, roadLength);
            const kerbMat = new THREE.MeshStandardMaterial({ color: 0xff0000 }); 
            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMat);
            kerbLeft.position.set(-roadWidth / 2 - kerbWidth / 2, 0.1, 0);
            kerbLeft.castShadow = true;
            kerbLeft.receiveShadow = true;
            scene.add(kerbLeft);

            const kerbRight = new THREE.Mesh(kerbGeo, kerbMat.clone());
            kerbRight.position.set(roadWidth / 2 + kerbWidth / 2, 0.1, 0);
            kerbRight.castShadow = true;
            kerbRight.receiveShadow = true;
            scene.add(kerbRight);
        }

        function createRoadLine(zPos) {
            const lineGeo = new THREE.BoxGeometry(0.3, 0.01, 4);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); 
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.set(0, 0.01, zPos);
            line.receiveShadow = true;
            roadLines.push(line);
            scene.add(line);
        }

        function setupRoadLines() {
            const numLines = roadLength / (4 + 4); 
            for (let i = 0; i < numLines; i++) {
                createRoadLine(-roadLength / 2 + i * 8);
            }
        }

        function createBuilding(zPos, isLeft) {
            const w = THREE.MathUtils.randFloat(4, 12);
            const h = THREE.MathUtils.randFloat(10, 40);
            const d = THREE.MathUtils.randFloat(4, 12);
            const geo = new THREE.BoxGeometry(w, h, d);
            const color = new THREE.Color().setHSL(Math.random(), 0.5, 0.7);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const building = new THREE.Mesh(geo, mat);

            const xPos = (isLeft ? -1 : 1) * (roadWidth / 2 + kerbWidth + w / 2 + THREE.MathUtils.randFloat(2, 5));
            building.position.set(xPos, h / 2, zPos);
            building.castShadow = true;
            building.receiveShadow = true;

            buildings.push(building);
            scene.add(building);
        }

        function setupBuildings() {
            const numBuildings = roadLength / buildingSpacing;
            for (let i = 0; i < numBuildings; i++) {
                const zPos = -roadLength / 2 + i * buildingSpacing + THREE.MathUtils.randFloat(0, buildingSpacing / 2);
                createBuilding(zPos, true); 
                createBuilding(zPos, false); 
            }
        }

        function createStreetLight(zPos, isLeft) {
            const lightGroup = new THREE.Group();

            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 3;
            pole.castShadow = true;
            lightGroup.add(pole);

            const armGeo = new THREE.BoxGeometry(1, 0.1, 0.1);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const arm = new THREE.Mesh(armGeo, armMat);
            arm.position.set(isLeft ? 0.5 : -0.5, 5.8, 0);
            lightGroup.add(arm);

            const lightGeo = new THREE.SphereGeometry(0.2, 16, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2 });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.set(isLeft ? 1 : -1, 5.8, 0);
            lightGroup.add(light);

            const xPos = (isLeft ? -1 : 1) * (roadWidth / 2 + kerbWidth + 1);
            lightGroup.position.set(xPos, 0, zPos);
            lights.push(lightGroup);
            scene.add(lightGroup);
        }

        function setupLights() {
            const numLights = roadLength / lightSpacing;
            for (let i = 0; i < numLights; i++) {
                const zPos = -roadLength / 2 + i * lightSpacing;
                createStreetLight(zPos, true); 
                createStreetLight(zPos, false); 
            }
        }

        function setupTrafficLights() {
            const zPos = roadLength * 0.4;
            
            const poleGeo = new THREE.CylinderGeometry(0.15, 0.15, 5, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const poleLeft = new THREE.Mesh(poleGeo, poleMat);
            poleLeft.position.set(-roadWidth / 2 - 1, 2.5, zPos);
            scene.add(poleLeft);

            const poleRight = poleLeft.clone();
            poleRight.position.x = roadWidth / 2 + 1;
            scene.add(poleRight);

            const housingGeo = new THREE.BoxGeometry(0.5, 1.2, 0.3);
            const housingMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

            const housingLeft = new THREE.Mesh(housingGeo, housingMat);
            housingLeft.position.set(-roadWidth / 2 - 1, 4.8, zPos);
            scene.add(housingLeft);

            const housingRight = housingLeft.clone();
            housingRight.position.x = roadWidth / 2 + 1;
            scene.add(housingRight);

            const lightColors = [0xff0000, 0xffff00, 0x00ff00];
            for (let i = 0; i < 3; i++) {
                const lightGeo = new THREE.SphereGeometry(0.1, 16, 8);
                const lightMat = new THREE.MeshBasicMaterial({ color: lightColors[i], emissive: lightColors[i], emissiveIntensity: (i === 0 ? 1 : 0.1) }); 

                const lightLeft = new THREE.Mesh(lightGeo, lightMat);
                lightLeft.position.set(-roadWidth / 2 - 1, 5.3 - i * 0.4, zPos + 0.15);
                scene.add(lightLeft);

                const lightRight = lightLeft.clone();
                lightRight.position.x = roadWidth / 2 + 1;
                scene.add(lightRight);
            }
        }

        function createPoint() {
            const geo = new THREE.SphereGeometry(0.3, 16, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.5 });
            const point = new THREE.Mesh(geo, mat);

            const box = new THREE.Box3();
            point.userData = { box: box, active: true }; 

            points.push(point);
            scene.add(point);
            pointBoxes.push(box);
            return point;
        }

        function setupPoints() {
            for (let i = 0; i < 15; i++) {
                const point = createPoint();
                recyclePoint(point);
            }
        }
        // --- Asset Loading and Fallback (omitted for brevity, assume unchanged) ---
        // ... (All original loading functions remain here)
        function loadAssets() {
            const manager = new THREE.LoadingManager();
            manager.onStart = (url, itemsLoaded, itemsTotal) => {
                loadingScreen.textContent = 'Loading...';
            };

            manager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const progress = Math.round((itemsLoaded / itemsTotal) * 100);
                loadingScreen.textContent = `Loading ${progress}%...`;
            };

            manager.onLoad = () => {
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    animate(); 
                }, 500);
            };

            manager.onError = (url) => {
                console.error('There was an error loading ' + url);
                loadingScreen.textContent = 'Error loading assets. Check console.';
                createCarFallback(); 
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    animate();
                }, 1000);
            };

            const dracoLoader = new DRACOLoader(manager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');

            const loader = new GLTFLoader(manager);
            loader.setDRACOLoader(dracoLoader);

            loader.load(
                'https://threejs.org/examples/models/gltf/ferrari.glb',
                (gltf) => {
                    gltf.scene.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    playerCar = gltf.scene;
                    playerCar.scale.set(0.8, 0.8, 0.8);
                    playerCar.rotation.y = Math.PI; 
                    playerCar.position.x = 0;
                    playerCar.position.z = 0;

                    const bbox = new THREE.Box3().setFromObject(playerCar);
                    carBaseY = (bbox.max.y - bbox.min.y) / 2;
                    playerCar.position.y = carBaseY;
                    camera.position.y = carBaseY + 3;
                    directionalLight.target = playerCar;

                    scene.add(playerCar);

                    enemyCar = playerCar.clone();
                    enemyCar.traverse((child) => {
                        if (child.isMesh) {
                            child.material = child.material.clone();
                            child.material.color.set(0x0000ff);
                        }
                    });
                    recycleEnemyCar(); 
                    scene.add(enemyCar);

                    playerBox = new THREE.Box3().setFromObject(playerCar);
                    enemyBox = new THREE.Box3().setFromObject(enemyCar);

                },
                undefined, 
                (error) => {
                    console.error('Error loading car model GLTF:', error);
                    createCarFallback();
                }
            );
        }

        function createCarFallback() {
            carBaseY = 0.51; 
            const geo = new THREE.BoxGeometry(2, 1, 4);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            playerCar = new THREE.Mesh(geo, mat);
            playerCar.position.set(0, carBaseY, 0);
            playerCar.castShadow = true;
            playerCar.receiveShadow = true;
            scene.add(playerCar);

            const enemyMat = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            enemyCar = new THREE.Mesh(geo, enemyMat);
            enemyCar.castShadow = true;
            enemyCar.receiveShadow = true;
            recycleEnemyCar();
            scene.add(enemyCar);

            playerBox = new THREE.Box3().setFromObject(playerCar);
            enemyBox = new THREE.Box3().setFromObject(enemyCar);
        }

        // --- Recycling and Resetting ---

        function recycleRoadLine(line) {
            line.position.z = roadLength / 2;
        }

        function recycleBuilding(building) {
            const w = THREE.MathUtils.randFloat(4, 12);
            const h = THREE.MathUtils.randFloat(10, 40);
            const d = THREE.MathUtils.randFloat(4, 12);
            const geo = new THREE.BoxGeometry(w, h, d);
            building.geometry.dispose();
            building.geometry = geo;

            const isLeft = building.position.x < 0;
            const xPos = (isLeft ? -1 : 1) * (roadWidth / 2 + kerbWidth + w / 2 + THREE.MathUtils.randFloat(2, 5));

            building.position.set(xPos, h / 2, roadLength / 2);
        }

        function recycleLight(light) {
            light.position.z = roadLength / 2;
        }
        
        // **MODIFIED:** Enemy Car spawns in one of the three lanes (Left, Center, Right)
        function recycleEnemyCar() {
            // Randomly pick a lane position: -roadWidth/4, 0, or roadWidth/4
            const randomIndex = Math.floor(Math.random() * lanePositions.length);
            const lane = lanePositions[randomIndex];
            
            // Spawn far up the road
            const zPos = roadLength * 0.7 + THREE.MathUtils.randFloat(0, roadLength * 0.3);
            enemyCar.position.set(lane, carBaseY, zPos);
        }

        function recyclePoint(point) {
            point.userData.active = true;
            point.visible = true;
            const x = THREE.MathUtils.randFloat(-roadWidth / 2 + 1, roadWidth / 2 - 1);
            const z = roadLength / 2 + THREE.MathUtils.randFloat(0, roadLength / 4);
            point.position.set(x, 0.5, z);
            point.userData.box.setFromObject(point);
        }

        // --- Game Mechanics / Update Loop ---

        function updateScenery(delta) {
            const moveDist = driveSpeed * delta * 60; 

            roadLines.forEach(line => {
                line.position.z -= moveDist;
                if (line.position.z < -roadLength / 2) {
                    recycleRoadLine(line);
                }
            });

            buildings.forEach(building => {
                building.position.z -= moveDist;
                if (building.position.z < -roadLength / 2) {
                    recycleBuilding(building);
                }
            });

            lights.forEach(light => {
                light.position.z -= moveDist;
                if (light.position.z < -roadLength / 2) {
                    recycleLight(light);
                }
            });
        }

        function updatePlayerCar(delta) {
            if (!playerCar) return;

            const currentX = playerCar.position.x;
            const targetX = currentX + (moveRight ? carMoveSpeed * delta * 60 : moveLeft ? -carMoveSpeed * delta * 60 : 0);

            const maxRight = roadWidth / 2 - kerbWidth - carHalfWidth;
            const clampedX = THREE.MathUtils.clamp(targetX, -maxRight, maxRight);

            playerCar.position.x = clampedX;
            playerBox.setFromObject(playerCar); 
        }

        function updateEnemyCar(delta) {
            if (!enemyCar) return;

            enemyCar.position.z -= enemyCarSpeed * delta * 60;
            if (enemyCar.position.z < -roadLength / 2) {
                recycleEnemyCar();
            }
            enemyBox.setFromObject(enemyCar); 
        }

        function updatePoints(delta) {
            points.forEach(point => {
                point.position.z -= driveSpeed * delta * 60;
                point.rotation.y += 0.05;

                if (point.position.z < -roadLength / 2) {
                    recyclePoint(point);
                }
                if (point.userData.active) {
                    point.userData.box.setFromObject(point); 
                }
            });
        }

        function checkCollisions() {
            if (!playerCar || !enemyCar) return;

            // Player-Enemy Collision
            if (playerBox.intersectsBox(enemyBox)) {
                isGameOver = true;
                
                // Update Best Score before stopping
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('bestScore', bestScore);
                    bestScoreDisplay.textContent = `Best: ${bestScore}`;
                    // Optionally update game over message to reflect new best
                    gameOverDisplay.textContent = `GAME OVER!\nNew Best Score: ${bestScore}`;
                } else {
                    gameOverDisplay.textContent = `GAME OVER!\nScore: ${score}`;
                }

                gameOverDisplay.style.display = 'block';
                return;
            }

            // Player-Point Collisions
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (point.userData.active && playerBox.intersectsBox(point.userData.box)) {
                    score += 10;
                    scoreDisplay.textContent = `Score: ${score}`;
                    point.userData.active = false;
                    point.visible = false;
                    setTimeout(() => recyclePoint(point), 100);
                }
            }
        }

        function updateCamera(delta) {
            const targetX = playerCar.position.x;
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX, 0.1);

            camera.lookAt(
                playerCar.position.x,
                carBaseY + 1,
                playerCar.position.z + 5
            );

            directionalLight.target.position.copy(playerCar.position);
            directionalLight.target.updateMatrixWorld();
        }

        // --- Event Handlers (omitted for brevity, assume unchanged) ---
        // ... (All original event handlers remain here)
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRight = false;
                    break;
            }
        }

        function setupTouchControls() {
            const preventDefault = (e) => e.preventDefault();
            const setMove = (isLeft, value) => {
                isLeft ? (moveLeft = value) : (moveRight = value);
            };

            [leftButton, rightButton].forEach(btn => {
                btn.addEventListener('touchstart', preventDefault, { passive: false });
                btn.addEventListener('touchend', preventDefault, { passive: false });
                btn.addEventListener('touchcancel', preventDefault, { passive: false });
            });

            leftButton.addEventListener('touchstart', () => setMove(true, true));
            leftButton.addEventListener('touchend', () => setMove(true, false));
            leftButton.addEventListener('touchcancel', () => setMove(true, false));

            rightButton.addEventListener('touchstart', () => setMove(false, true));
            rightButton.addEventListener('touchend', () => setMove(false, false));
            rightButton.addEventListener('touchcancel', () => setMove(false, false));
        }


        // --- Animation Loop ---

        function animate() {
            if (isGameOver) return;

            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (playerCar && enemyCar) { 
                updateScenery(delta);
                updatePlayerCar(delta);
                updateEnemyCar(delta);
                updatePoints(delta);
                checkCollisions();
                updateCamera(delta);
            }

            renderer.render(scene, camera);
        }

        // Start the game initialization
        init();

    </script>
</body>
</html>